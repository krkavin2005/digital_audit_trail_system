const express = require("express");
const fs = require("fs");
const crypto = require("crypto");
const { timeStamp } = require("console");
const PDFDocument = require("pdfkit");
const AuditEvent = require("./models/AuditEvent");
const LOG_FILE = "events.log";
const app = express();
const privateKey = fs.readFileSync("private.pem","utf8");
const publicKey = fs.readFileSync("public.pem","utf8");

app.use(express.json());

function getAuditLogs(){
    const data = fs.readFileSync(LOG_FILE,"utf-8");
    return data.trim().split("\n").map(line => JSON.parse(line));
}

function canonicalStringify(obj){
    return JSON.stringify(Object.keys(obj).sort().reduce((acc , key)=>{
        acc[key] = obj[key];
        return acc;
    }))
}

function computeHash(eventData , prevHash){
    const payload = canonicalStringify(eventData);
    return crypto.createHash("sha256").update(payload + prevHash).digest("hex");
}

async function getPreviousHash(){
    const lastEvent = await AuditEvent.findOne({}).sort({timestamp : -1}).lean();
    return lastEvent ? lastEvent.hash : "0".repeat(64);
}

async function recordEvent(actorId , actor , actorRole , action , target){
    const prevHash = await getPreviousHash();
    const eventId = (await AuditEvent.countDocuments())+ 1;
    const event = {
        eventId,
        actorId,
        actor,
        actorRole,
        action,
        target,
        timestamp: Date.now()
    };
    const hash = computeHash(event , prevHash);
    await AuditEvent.create({...event , prevHash , hash});
    console.log("Recorded: ", hash);
}

function verifyAuditLog(events){
    let prevHash = "0".repeat(64);
    for(let i = 0 ; i < events.length; i ++){
        const {hash , ...eventData} = events[i];
        const recomputedHash = computeHash(eventData , prevHash);
        if(recomputedHash !== hash){
            return{
                valid : false,
                brokenAt : i,
                expected : recomputedHash,
                found : hash
            };
        }
        prevHash = hash;
    }
    return {valid : true};
}

function requireRole(allowedRoles){
    return (req , res , next)=>{
        const role = req.headers["x-role"];
        if(!role){
            return res.status(401).json({
                status : "DENIED",
                message : "Role not provided"
            });
        }
        if(!allowedRoles.includes(role)){
            return res.status(403).json({
                status : "FORBIDDEN",
                message : "Unprevileged access"
            });
        }
        next();
    };
}

function generateVerificationReport(events){
    const result = verifyAuditLog(events);
    const baseReport = {
        verifiedAt : new Date().toISOString(),
        totalRcords : events.length
    };
    if(result.valid){
        return{
            ...baseReport,
            status : "VALID",
            message : "Audit trail integrity verified successfully"
        };
    }
    return {
        ...baseReport,
        status : "TAMPERED",
        brokenAt: result.brokenAt,
        expectedHash : result.expected,
        foundHash : result.found,
        message : "Audit log integrity violation detected"
    };
}

function generatePDFReport(report , res){
    const signature = signReport(report);
    const doc = new PDFDocument({margin : 50});
    res.setHeader("Content-Type","application/pdf");
    res.setHeader("Content-Disposition",`attachment ; filename = audit_report_${report.verifiedAt}.pdf`);
    doc.pipe(res);
    doc.fontSize(18).text("Digital Audit Trail Verification Report",{align : "center"});
    doc.moveDown(2);
    doc.fontSize(12);
    doc.text(`Verification Time : ${report.verifiedAt}`);
    doc.text(`Total Records Checked : ${report.totalRcords}`);
    doc.text(`Status : ${report.status}`);
    doc.moveDown();
    if(report.status === "VALID"){
        doc.fillColor("green");
        doc.text("Audit trail integrity verified successfully.");
    }
    else{
        doc.fillColor("red");
        doc.text("Audit trail integrity violation detected.");
        doc.moveDown();
        doc.text(`Broken At Index : ${report.brokenAt}`);
        doc.text(`ExpectedHash : ${report.expectedHash}`);
        doc.text(`Found Hash : ${report.foundHash}`);
    }
    doc.moveDown(2);
    doc.fillColor("black").fontSize(10).text("Digital Signature: ");
    doc.moveDown();
    doc.text(signature, {width : 500});
    doc.moveDown(2);
    doc.text("This report was generated by the Audit Trail System.",{align : "center"});
    doc.end();
}

function signReport(report){
    const reportString = JSON.stringify(report);
    const hash = crypto.createHash("sha256").update(reportString).digest();
    const signature = crypto.sign("RSA-SHA256", hash , privateKey);
    return signature.toString("base64");
}

function verifySignature(report , signature){
    const reportString = JSON.stringify(report);
    const hash = crypto.createHash("sha256").update(reportString).digest();
    return crypto.verify("RSA-SHA256", hash , publicKey , Buffer.from(signature ,"base64"));
}

function getPublicKeyFingerprint(){
    return crypto.createHash("sha256").update(publicKey).digest("hex");
}

app.get("/verify",requireRole(["auditor"]),(req,res)=>{
    try{
        const events = getAuditLogs();
        const result = verifyAuditLog(events);
        res.status(200).json({result});
    }catch(err){
        res.status(500).json({err});
    }
});

app.get("/logs", requireRole(["auditor"]),(req,res)=>{
    try{
        let events = getAuditLogs();
        const {actor , action , from , to} = req.query;
        if(actor){
            events = events.filter(e => e.actor === actor);
        }
        if(action){
            events = events.filter(e => e.action === action);
        }
        if(from){
            const fromDate = new Date(from);
            events = events.filter(e => new Date(e.timeStamp)>= fromDate);
        }
        if(to){
            const toDate = new Date(to);
            toDate.setDate(toDate.getDate() + 1)//accounts only till midnight(12:AM). so +1 for the entire day
            events = events.filter(e => new Date(e.timeStamp)<= toDate);
        }
        const cleaned = events.map(({prevHash, ...rest})=> rest);
        res.status(200).json({
            count : cleaned.length,
            logs : cleaned
        });
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

app.get("/verify/report" , requireRole(["auditor"]),(req , res)=>{
    try{
        const events = getAuditLogs();
        const report = generateVerificationReport(events);
        res.json(report);
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

app.get("/verify/report/download",(req,res)=>{
    try{
        const events = getAuditLogs();
        const report = generateVerificationReport(events);
        generatePDFReport(report , res);
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

app.post("/verify/report/validate", requireRole(["auditor"]),(req , res)=>{
    try {
        const {report , signature}= req.body;
        if(!report || !signature){
            return res.status(400).json({
                status : "INVALID_REQUEST",
                message : "Report and signature are required"
            });
        }
        const isValid = verifySignature(report , signature);
        if(isValid){
            return res.status(200).json({
                status : "VALID",
                message : "Signature is valid. Report is authentic and unmodified"
            });
        }
        return res.status(200).json({
            status : "INVALID",
            message : "Signature verification failed. Report may be tampered."
        });
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

app.get("/keys/public/fingerprint",(req , res)=>{
    try{
        const fingerprint = getPublicKeyFingerprint();
        res.json({fingerprint});
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

// const events = getAuditLogs();
// console.log(verifyAuditLog(events));
// recordEvent("irfahn","LOGIN","system");
// recordEvent("malan","CHANGE_ROLE","irfahn");
// recordEvent("u1", "Alice", "ADMIN", "SYSTEM_START", "audit_service").catch(console.error);
// recordEvent("u2", "Bob", "AUDITOR", "DATA_ACCESS", "financial_records").catch(console.err);
// recordEvent("u1", "Alice", "ADMIN", "REPORT_GENERATED", "audit_report").catch(console.error);


app.listen(3000,() => {
    console.log("Audit System running on port 3000");
});