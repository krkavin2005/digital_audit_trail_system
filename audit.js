const express = require("express");
const fs = require("fs");
const crypto = require("crypto");
const { timeStamp } = require("console");
const PDFDocument = require("pdfkit");
const AuditEvent = require("./models/AuditEvent");
const { randomUUID } = require("crypto");
const VerificationReport = require("./models/VerificationReport");
const LOG_FILE = "events.log";
const app = express();
const privateKey = fs.readFileSync("private.pem","utf8");
const publicKey = fs.readFileSync("public.pem","utf8");

app.use(express.json());

async function getAuditLogs(obj){
    return await AuditEvent.find(obj).sort({eventId : 1}).lean();
}

function canonicalStringify(obj){
    return JSON.stringify(Object.keys(obj).sort().reduce((acc , key)=>{
        acc[key] = obj[key];
        return acc;
    },{}))
}

function computeHash(eventData , prevHash){
    const payload = canonicalStringify(eventData);
    return crypto.createHash("sha256").update(payload + prevHash).digest("hex");
}

async function getPreviousHash(){
    const lastEvent = await AuditEvent.findOne({}).sort({timestamp : -1}).lean();
    return lastEvent ? lastEvent.hash : "0".repeat(64);
}

async function recordEvent(actorId , actor , actorRole , action , target){
    const prevHash = await getPreviousHash();
    const eventId = (await AuditEvent.countDocuments())+ 1;
    const event = {
        eventId,
        actorId,
        actor,
        actorRole,
        action,
        target,
        timestamp: new Date()
    };
    const hash = computeHash(event , prevHash);
    await AuditEvent.create({...event , prevHash , hash});
    console.log("Recorded: ", hash);
}

 async function verifyAuditLog(){
    const events = await AuditEvent.find({}).sort({eventId : 1}).lean();
    if(events.length === 0){
        return {valid : true , message : "No audit events found"};
    }
    for(let i = 0 ; i < events.length ; i ++){
        const {_id , hash , prevHash ,...eventData}= events[i];
        const recomputedHash = computeHash(eventData , prevHash);
        if(recomputedHash !== hash){
            return{
                valid : false,
                brokenAt : i,
                expected : recomputedHash,
                found : hash
            };
        }
    }
    return {valid : true};
}

function requireRole(allowedRoles){
    return (req , res , next)=>{
        const role = req.headers["x-role"];
        if(!role){
            return res.status(401).json({
                status : "DENIED",
                message : "Role not provided"
            });
        }
        if(!allowedRoles.includes(role)){
            return res.status(403).json({
                status : "FORBIDDEN",
                message : "Unprevileged access"
            });
        }
        next();
    };
}

async function generateVerificationReport(){
    const result = await verifyAuditLog();
    const report = {
        reportId : randomUUID(),
        verifiedAt : new Date().toISOString(),
        totalRecords : await AuditEvent.countDocuments(),
        verifier : "SYSTEM"
    };
    if(result.valid){
        report.status ="VALID";
    }
    else {
        report.status = "TAMPERED";
        report.brokenAt = result.brokenAt;
        report.expectedHash = result.expected;
        report.foundHash = result.found;
    }
    report.fromEvent = 1;
    report.signature = signReport(report);
    await VerificationReport.create(report);
    return report;
}

function generatePDFReport(report , res){
    const doc = new PDFDocument({margin : 50});
    res.setHeader("Content-Type","application/pdf");
    res.setHeader("Content-Disposition",`attachment ; filename = audit_report_${report.verifiedAt}.pdf`);
    doc.pipe(res);
    doc.fontSize(18).text("Digital Audit Trail Verification Report",{align : "center"});
    doc.moveDown(2);
    doc.fontSize(12);
    doc.text(`Verification Time : ${report.verifiedAt}`);
    doc.text(`Total Records Checked : ${report.totalRecords}`);
    doc.text(`Status : ${report.status}`);
    doc.moveDown();
    if(report.status === "VALID"){
        doc.fillColor("green");
        doc.text("Audit trail integrity verified successfully.");
    }
    else{
        doc.fillColor("red");
        doc.text("Audit trail integrity violation detected.");
        doc.moveDown();
        doc.text(`Broken At Index : ${report.brokenAt}`);
        doc.text(`ExpectedHash : ${report.expectedHash}`);
        doc.text(`Found Hash : ${report.foundHash}`);
    }
    doc.moveDown(2);
    doc.fillColor("black").fontSize(10).text("Digital Signature: ");
    doc.moveDown();
    doc.text(report.signature, {width : 500});
    doc.moveDown(2);
    doc.text("This report was generated by the Audit Trail System.",{align : "center"});
    doc.end();
}

function signReport(report){
    const reportString = JSON.stringify(report);
    const hash = crypto.createHash("sha256").update(reportString).digest();
    const signature = crypto.sign("RSA-SHA256", hash , privateKey);
    return signature.toString("base64");
}

function verifySignature(report , signature){
    const reportString = JSON.stringify(report);
    const hash = crypto.createHash("sha256").update(reportString).digest();
    return crypto.verify("RSA-SHA256", hash , publicKey , Buffer.from(signature ,"base64"));
}

function getPublicKeyFingerprint(){
    return crypto.createHash("sha256").update(publicKey).digest("hex");
}

app.get("/verify",requireRole(["AUDITOR"]),async(req,res)=>{
    try{
        const result = await verifyAuditLog();
        console.log(result);
        res.status(200).json({result});
    }catch(err){
        res.status(500).json({err});
    }
});

app.get("/logs", requireRole(["AUDITOR"]),async(req,res)=>{
    try{
        const filters = {};
        const {actor , action , from , to} = req.query;
        if(actor){
            filters.actor = actor;
        }
        if(action){
            filters.action = action;
        }
        if(from || to){
            filters.time = {};
            if(from){
                filters.time.$gte = new Date(from);
            }
            if(to){
                const toDate = new Date(to);
                toDate.setDate(toDate.getDate()+ 1);
                filters.time.$lte = toDate;
            }
        }
        const events = await getAuditLogs(filters);
        const cleaned = events.map(({prevHash, ...rest})=> rest);
        res.status(200).json({
            count : cleaned.length,
            logs : cleaned
        });
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

app.get("/verify/report" , requireRole(["AUDITOR"]),async(req , res)=>{
    try{
        const report = await generateVerificationReport();
        res.json(report);
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

app.get("/verify/report/download",async (req,res)=>{
    try{
        const report = await generateVerificationReport();
        generatePDFReport(report , res);
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

app.post("/verify/report/validate", requireRole(["AUDITOR"]),(req , res)=>{
    try {
        const {report , signature}= req.body;
        if(!report || !signature){
            return res.status(400).json({
                status : "INVALID_REQUEST",
                message : "Report and signature are required"
            });
        }
        const isValid = verifySignature(report , signature);
        if(isValid){
            return res.status(200).json({
                status : "VALID",
                message : "Signature is valid. Report is authentic and unmodified"
            });
        }
        return res.status(200).json({
            status : "INVALID",
            message : "Signature verification failed. Report may be tampered."
        });
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

app.get("/keys/public/fingerprint",(req , res)=>{
    try{
        const fingerprint = getPublicKeyFingerprint();
        res.json({fingerprint});
    }catch(err){
        res.status(500).json({err : err.message});
    }
});

// const events = getAuditLogs();
// console.log(verifyAuditLog(events));
// recordEvent("irfahn","LOGIN","system");
// recordEvent("malan","CHANGE_ROLE","irfahn");
// recordEvent("u1", "Alice", "ADMIN", "SYSTEM_START", "audit_service").catch(console.error);
// recordEvent("u2", "Bob", "AUDITOR", "DATA_ACCESS", "financial_records").catch(console.err);
// recordEvent("u1", "Alice", "ADMIN", "REPORT_GENERATED", "audit_report").catch(console.error);
// recordEvent("u3","Charlie","USER","LOGIN_FAILURE","authentication_service").catch(console.error);
// recordEvent("u2","Bob","AUDITOR","AUDIT_VERIFICATION","audit_log_chain").catch(console.error);
// recordEvent("u1","Alice","ADMIN","ROLE_UPDATED","user:u3").catch(console.error);

app.listen(3000,() => {
    console.log("Audit System running on port 3000");
});